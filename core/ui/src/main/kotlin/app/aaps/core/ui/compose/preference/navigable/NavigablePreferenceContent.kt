package app.aaps.core.ui.compose.preference.navigable

import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import app.aaps.core.keys.interfaces.PreferenceItem
import app.aaps.core.keys.interfaces.PreferenceKey
import app.aaps.core.ui.compose.preference.PreferenceSectionState
import app.aaps.core.ui.compose.preference.PreferenceSubScreenDef

/**
 * Interface for plugins that provide navigable preference subscreens.
 * Plugins implement this to define their preference UI with hierarchical navigation.
 *
 * @deprecated Legacy pattern - new code should use PreferenceSubScreenDef instead
 */
interface NavigablePreferenceContent {

    /**
     * Unique key prefix for this plugin's preferences.
     */
    val keyPrefix: String
        get() = this::class.java.simpleName

    /**
     * String resource ID for the main section title.
     */
    val titleResId: Int

    /**
     * Unified list of preference items (keys and subscreens) preserving display order.
     * This allows subscreens to be interspersed with regular preferences.
     * If not overridden, derived from mainKeys + subscreens for backward compatibility.
     */
    val items: List<PreferenceItem>
        get() = mainKeys + subscreens

    /**
     * Main preference keys shown at top level.
     * Summary is auto-derived from keys' titleResId.
     * For backward compatibility - new code should use [items] instead.
     */
    val mainKeys: List<PreferenceKey>
        get() = emptyList()

    /**
     * Optional list of preference title resource IDs to show as summary when collapsed.
     * Used when the card is collapsed to show what preferences are available.
     * If empty, derived from items.
     */
    val summaryItems: List<Int>
        get() = emptyList()

    /**
     * Effective summary items - from items if available, otherwise summaryItems.
     */
    fun effectiveSummaryItems(): List<Int> {
        val fromItems = items.flatMap { item ->
            when (item) {
                is PreferenceKey -> listOf(item.titleResId).filter { it != 0 }
                is PreferenceSubScreenDef -> item.keys.map { it.titleResId }.filter { it != 0 }
                is PreferenceSubScreen -> item.keys.map { it.titleResId }.filter { it != 0 }
                else -> emptyList()
            }
        }
        return if (fromItems.isNotEmpty()) fromItems else summaryItems.ifEmpty {
            subscreens.map { it.titleResId }
        }
    }

    /**
     * Optional main content shown at top level (not in a subscreen).
     * These preferences are displayed directly, with subscreens below.
     */
    val mainContent: (@Composable (PreferenceSectionState?) -> Unit)?
        get() = null

    /**
     * List of subscreens available in this preference screen.
     * For backward compatibility - new code should use [items] instead.
     * Converts PreferenceSubScreenDef to PreferenceSubScreen with auto-generated content.
     */
    val subscreens: List<PreferenceSubScreen>
        get() = emptyList()

    /**
     * Override this to provide auto-generated content for PreferenceSubScreenDef.
     * Default implementation shows a placeholder.
     */
    @Composable
    fun renderAutoGeneratedContent(def: PreferenceSubScreenDef) {
        Text("Auto-generated content for ${def.key} - override renderAutoGeneratedContent")
    }
}
